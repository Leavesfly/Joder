# Joder 单元测试快速参考

## 测试文件位置

```
joder/src/test/java/io/shareai/joder/
├── core/
│   └── config/
│       └── ConfigManagerTest.java (20 个测试)
│   └── permission/
│       ├── PermissionManagerTest.java (14 个测试)
│       └── PermissionModeTest.java (15 个测试)
├── domain/
│   ├── MessageTest.java (8 个测试)
│   └── MessageRoleTest.java (8 个测试)
└── tools/
    ├── AbstractToolTest.java (18 个测试)
    ├── ToolRegistryTest.java (16 个测试)
    ├── ToolResultTest.java (14 个测试)
    └── file/
        └── FileReadToolTest.java (27 个测试)
```

## 快速命令

### 构建项目
```bash
cd joder
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home
mvn clean package -DskipTests
```

### 运行所有测试
```bash
mvn test
```

### 运行特定的测试类
```bash
# 运行消息模型测试
mvn test -Dtest=MessageTest

# 运行工具注册表测试
mvn test -Dtest=ToolRegistryTest

# 运行权限管理器测试
mvn test -Dtest=PermissionManagerTest

# 运行文件读取工具测试
mvn test -Dtest=FileReadToolTest
```

### 运行多个特定的测试类
```bash
mvn test -Dtest=MessageTest,ToolResultTest,ToolRegistryTest
```

### 运行特定的测试方法
```bash
mvn test -Dtest=MessageTest#testCreateMessageWithAutoGeneratedIdAndTimestamp
```

### 查看测试覆盖率（需要安装 JaCoCo）
```bash
mvn test jacoco:report
```

## 测试组织结构

### 按模块分类

#### 1. Domain 层 (消息模型)
- `MessageTest` - 消息实体的生命周期测试
- `MessageRoleTest` - 消息角色枚举测试

#### 2. Tools 层 (工具系统)
- `ToolResultTest` - 工具执行结果
- `AbstractToolTest` - 工具基类和参数处理
- `ToolRegistryTest` - 工具注册和管理
- `FileReadToolTest` - 文件读取工具实现

#### 3. Core 层 (系统核心)
- `ConfigManagerTest` - 配置管理
- `PermissionModeTest` - 权限模式定义
- `PermissionManagerTest` - 权限检查逻辑

## 测试设计模式

### AAA 模式（Arrange-Act-Assert）
所有测试都遵循这个模式：
```java
@Test
public void testExample() {
    // Arrange - 准备测试数据
    String expectedValue = "expected";
    
    // Act - 执行被测试的代码
    String actualValue = someMethod();
    
    // Assert - 验证结果
    assertEquals(expectedValue, actualValue);
}
```

### 测试命名约定
- 类名：`被测试类名 + Test`
- 方法名：`test + 功能描述`
- 示例：`testCreateMessageWithAutoGeneratedId`

### DisplayName 注解
每个测试都有清晰的中文描述：
```java
@Test
@DisplayName("应该创建带有自动生成ID和时间戳的消息")
public void testCreateMessageWithAutoGeneratedIdAndTimestamp() {
    // ...
}
```

## 测试用例统计

| 模块 | 测试文件数 | 测试用例数 |
|------|----------|----------|
| Domain | 2 | 16 |
| Tools | 4 | 75 |
| Core | 3 | 49 |
| **总计** | **9** | **129** |

## 常见测试场景

### 1. 测试成功路径
```java
@Test
@DisplayName("应该成功读取文件")
public void testReadFile() {
    // Arrange
    Path file = createTestFile("content");
    
    // Act
    ToolResult result = fileReadTool.call(input);
    
    // Assert
    assertTrue(result.isSuccess());
}
```

### 2. 测试错误路径
```java
@Test
@DisplayName("读取不存在的文件应该返回错误")
public void testReadNonexistentFile() {
    // Act
    ToolResult result = fileReadTool.call(input);
    
    // Assert
    assertFalse(result.isSuccess());
    assertTrue(result.getError().contains("不存在"));
}
```

### 3. 测试参数验证
```java
@Test
@DisplayName("缺少必需参数应该返回错误")
public void testMissingParameter() {
    // Act & Assert
    assertThrows(IllegalArgumentException.class, () -> {
        tool.call(emptyInput);
    });
}
```

### 4. 使用 Mock 对象
```java
@Test
@ExtendWith(MockitoExtension.class)
public void testWithMock(@Mock ConfigManager configManager) {
    // Arrange
    when(configManager.getString("key", "default"))
        .thenReturn("mocked_value");
    
    // Act & Assert
    // ...
}
```

## 调试测试

### 在 IDE 中运行单个测试
大多数 IDE（如 IntelliJ IDEA）支持：
1. 右键点击测试类或方法
2. 选择 "Run" 或 "Run with Coverage"

### 获取详细的测试输出
```bash
mvn test -X  # 详细调试输出
mvn test -e  # 显示异常堆栈跟踪
```

### 只运行失败的测试
```bash
mvn test --fail-at-end
```

## 添加新测试

### 步骤
1. 在 `src/test/java` 中创建对应的包结构
2. 创建 `*Test` 名称的测试类
3. 添加 `@DisplayName` 和 `@Test` 注解
4. 实现 AAA 模式的测试用例

### 示例模板
```java
package io.shareai.joder.tools;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import static org.junit.jupiter.api.Assertions.*;

@DisplayName("MyTool 工具测试")
public class MyToolTest {
    
    @Test
    @DisplayName("应该...")
    public void testSomething() {
        // Arrange
        
        // Act
        
        // Assert
    }
}
```

## 常见问题

### Q: 如何跳过某些测试？
A: 使用 `@Disabled` 注解
```java
@Test
@Disabled("还在开发中")
public void testWIP() {
    // ...
}
```

### Q: 如何参数化测试（测试多个数据）？
A: 使用 `@ParameterizedTest` 和 `@ValueSource`
```java
@ParameterizedTest
@ValueSource(strings = {"apple", "banana", "cherry"})
public void testWithMultipleValues(String value) {
    // ...
}
```

### Q: 如何设置和清理测试环境？
A: 使用 `@BeforeEach` 和 `@AfterEach`
```java
@BeforeEach
public void setUp() {
    // 在每个测试前执行
}

@AfterEach
public void tearDown() {
    // 在每个测试后执行
}
```

## 性能提示

- 测试应该快速运行（通常 < 1 秒）
- 避免在测试中进行 I/O 操作
- 使用 Mock 对象替代真实的外部依赖
- 使用 `@TempDir` 而不是实际文件系统进行文件测试

## 最佳实践

1. ✅ 每个测试只测试一个行为
2. ✅ 使用有意义的测试名称
3. ✅ 避免测试之间的依赖
4. ✅ 使用断言而不是 println 调试
5. ✅ 测试应该是独立的
6. ✅ 保持测试简洁易读
7. ✅ 定期运行完整的测试套件

---

**更新时间**: 2025-10-28  
**Java 版本**: 17  
**JUnit 版本**: 5  
**Mockito 版本**: 5.8.0
